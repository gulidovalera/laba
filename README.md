# Лабораторные работы по Python

## Файлы с кодом
- [Лаба-1 в1.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/Лаба-1%20в1.py) - Лабораторная работа 1
- [лаба2 (1).py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба2%20(1).py) - Лабораторная работа 2
- [лаба3задание1(3).py](https://github.com/gulidovalera/laba/blob/Labi/Python/%23В3задание1.py), [лаба3задание2(3).py](https://github.com/gulidovalera/laba/blob/Labi/Python/%23В3задание2(2).py) - Лабораторная работа 3
- [лаба4_В3_1задание.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба4_В3_1задание.py), [лаба4_В3_2задание.py](https://github.com/gulidovalera/laba/blob/лаба-1/Python/лаба4_В3_2задание.py) - Лабораторная работа 4
---

## Оформленный сайт с подключеной Метрикой - [Сайт](https://gulidovalera.github.io/laba/#) 
---

## Бонус ;)
- [Распределяющая Викторина Хогвартса (сайт)](https://gulidovalera.github.io/slytherin/)
- вариант викторины через терминал [код](https://github.com/gulidovalera/laba/blob/лаба-1/Bonus/hat_hogwarts.py)
___

# Лабораторная работа 1: "Моделирование роста популяции кроликов с использованием рекуррентных отношений"

## Цель работы
Исследование динамики роста популяции кроликов по модели Фибоначчи с модификацией, учитывающей рождение k пар кроликов в помёте. Реализация алгоритма для вычисления численности популяции на n-ый месяц с использованием динамического программирования.

## Задачи
1. Анализ классической задачи Фибоначчи о размножении кроликов
2. Модификация модели:
   - Учёт параметра k (количество пар в помёте)
   - Обобщение рекуррентного соотношения: F_n = F_{n-1} + k * F_{n-2}
3. Реализация алгоритма на Python
4. Тестирование программы на примере (n=5, k=3)

## Инструменты и алгоритмы
 Язык программирования: Python.
- Алгоритм:
  - Динамическое программирование для избежания рекурсивных вычислений.
  - Использование списка F для хранения промежуточных результатов.
  - Итеративное заполнение списка по формуле:
    ```python
    F[i] = F[i-1] + k * F[i-2]
    ```
- Структура программы:
  - Функция rabbit_pairs(n, k) вычисляет результат.
  - Ввод данных через input().split().
  - Вывод итогового значения.

## Ошибки и исправления
1. Ошибка: Неверная инициализация списка F для n=1.
   - Исправление: Добавлено условие if n > 1 для корректного задания F[2].
2. Ошибка: Невнимание к индексации месяцев (месяцы начинаются с 1, а не 0).
   - Исправление: Создание списка размером n+1 для удобства работы.

## Результат
![Screnshot](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_11-46-57.png)

## Выводы
1. Модель Фибоначчи успешно обобщена для случая рождения k пар кроликов.
2. Динамическое программирование позволило эффективно решить задачу без рекурсии (сложность O(n)).
3. Программа корректно работает для n ≤ 40 и k ≤ 5, что соответствует условиям задачи.
4. Практическое применение: анализ экологических систем (например, инвазивные виды, как кролики в Австралии).
---

# Лабораторная работа 2: "Работа с файлами в Python. Вычисление GC-состава"

## Цель работы
Разработать программу для анализа последовательностей ДНК в формате FASTA с целью определения GC-состава (доли гуанина (G) и цитозина (C)) и выявления последовательности с максимальным значением этого показателя.

## Задачи
1. Обработка входных данных:
   - Чтение последовательностей ДНК в формате FASTA.
   - Разделение идентификаторов (строки с >) и самих последовательностей.
2. Вычисление GC-состава:
   - Подсчёт количества символов G и C в каждой последовательности.
   - Расчёт доли GC-пар от общей длины последовательности (в процентах).
3. Анализ результатов:
   - Определение последовательности с наибольшим GC-составом.
   - Вывод результатов в заданном формате.

## Инструменты и алгоритмы
- Язык программирования: Python.
- Структуры данных:
  - Словарь sequences для хранения пар идентификатор: последовательность.
- Алгоритмы:
  - Чтение данных: Построчная обработка ввода с проверкой на начало идентификатора (>) или последовательности.
  - Расчёт GC-состава: Формула:
    ```python
    GC_content = (count('G') + count('C')) / len(sequence) * 100
    ```
  - Поиск максимума: Итерация по словарю с сравнением значений.
  - Форматирование вывода:
    - Округление результатов до двух знаков после запятой (:.2f).

## Ошибки и исправления
1. Ошибка: Некорректная обработка многострочных последовательностей.
   - Исправление: Добавление условия для конкатенации строк последовательности к текущему идентификатору.
2. Ошибка: Невнимание к регистру символов (например, g vs G).
   - Исправление: Предполагается, что входные данные в верхнем регистре (по условию задачи).
3. Ошибка: Отсутствие проверки на пустые последовательности.
   - Исправление: В данной задаче не требуется, так как входные данные гарантированно валидны.
## Результат
![](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_12-19-35.png)
![](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_12-20-03.png) 
## Выводы
- Успешная обработка до 10 последовательностей
- Применение для сравнения геномов и идентификации ДНК

---

# Лабораторная работа 3: "Представление данных в Python"

## Цель работы
Освоить методы визуализации данных в Python с использованием библиотеки matplotlib:
1. Построение диаграммы рассеяния для анализа взаимосвязи между признаками и их классификации.
2. Построение графиков временных рядов для изучения динамики изменения данных.

## Задания
### Задание 1. Построение диаграммы рассеяния
1. Загрузить данные (набор Iris).
2. Выбрать два признака для осей X и Y.
3. Визуализировать данные с цветовой дифференциацией по классам.
4. Добавить подписи, легенду и сетку для улучшения читаемости.

### Задание 2. Построение графика временных рядов
1. Загрузить данные (уровень CO₂).
2. Выбрать временной промежуток для анализа.
3. Построить график динамики изменений.
4. Настроить оформление (заголовок, подписи осей, сетку).

## Инструменты

 Библиотеки:
- `matplotlib.pyplot` для визуализации.
- `sklearn.datasets` для загрузки данных Iris.
-  `statsmodels.api` для CO₂
 Алгоритм задание 1:
- Загрузка данных:
  ```python
    load_iris()
    ```
- Разделение данных по классам:
   ```python
   self.y == label
    ```
- Построение scatter-графика:
  ```python
   plt.scatter()
    ```
- Настройка оформления: plt.xlabel(), plt.legend().

 Алгоритм задание 2:
- Загрузка данных:
  ```python
   sm.datasets.co2.load_pandas()
    ```
- Фильтрация по временному диапазону:
  ```python
  self.co2[start_date:end_date]
    ``` 
- Построение линейного графика: plt.plot().
- Настройка оформления: plt.title(), plt.grid().
  
## Ошибки и исправления
### Задание 1
1. Ошибка: Неверный выбор индексов признаков.
- Пример: Использование индексов 5 и 6 (выход за границы).
- Исправление: Проверка диапазона (0 ≤ index < 4).
2. Ошибка: Наложение подписей точек.
- Пример: Перекрывающиеся метки классов.
- Исправление: Увеличение размера графика (figsize=(12, 8)).
3. Ошибка: Неправильные цвета для классов.
- Пример: Повторение цветов (['red', 'red', 'blue']).
- Исправление: Уникальные цвета для каждого класса.
  ## Результат
  ![Screnshot](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_12-05-25.png)

### Задание 2
1. Ошибка: Неверный формат дат.
- Пример:
  ```python
   start_date='1958'  #отсутствует месяц и день
    ``` 
- Исправление: Указание полной даты ('1958-01-01').
2. Ошибка: Пропущенные данные в ряду.
- Пример: Пробелы в данных CO₂.
- Исправление: Интерполяция
   ```python
  self.co2.interpolate()
    ``` 
3. Ошибка: Слишком плотная сетка дат.
- Пример: Нечитаемые подписи на оси X.
- Исправление: Настройка частоты меток
   ```python
  plt.xticks(rotation=45)
    ``` 
![](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_11-59-19.png)
## Выводы
1. Результаты задания 1:
- Диаграмма рассеяния наглядно показывает кластеры видов ирисов по выбранным признакам.
- Цветовое разделение упрощает интерпретацию классов.
2. Результаты задания 2:
- График временного ряда CO₂ демонстрирует устойчивый рост концентрации за выбранный период.
- Настройка оформления улучшает восприятие динамики.
3. Общие выводы:
- Библиотека matplotlib предоставляет гибкие инструменты для визуализации данных.
- Важно учитывать потенциальные ошибки (формат данных, наложение графиков) для корректного отображения.

---

# Лабораторная работа 4: "Работа с BioPython"

## Цель работы
Обработка биологических данных в формате GenBank:
1. Объединение файлов
2. Анализ GC-состава
3. Трансляция кодирующих областей

## Задачи
### Задание 1. Формирование исходного файла
1. Загрузить по 5 CDS-последовательностей для двух видов с NCBI в формате GenBank.
2. Объединить записи в единый файл средствами BioPython.
3. Проверить, что итоговый файл содержит не менее 10 CDS.

### Задание 2. Анализ GC-составов
1. Прочитать файл GenBank, извлечь последовательности.
2. Вычислить GC-состав для каждой последовательности.
3. Отсортировать последовательности по возрастанию GC-состава.
4. Вывести результаты с указанием ID, описания и значения GC.

### Задание 3. Трансляция
1. Извлечь кодирующие области (CDS) из файла GenBank.
2. Транслировать нуклеотидные последовательности в аминокислотные.
3. Вывести белковые последовательности с указанием исходных CDS.

## Инструменты
### Задание 1
 Библиотеки:
- `Bio.SeqIO` для чтения/записи GenBank-файлов.
 Алгоритм:
- Скачивание данных с NCBI (вручную).
- Объединение файлов через SeqIO.write(records, "output.gb", "genbank").

### Задание 2
 Библиотеки:
- `Bio.SeqIO` для парсинга GenBank.
- `tkinter` для GUI.
*GUI — это графический пользовательский интерфейс. Название происходит от английского словосочетания graphical user interface. Так называется внешний вид программы — то, что видит пользователь и с чем он может взаимодействовать. 
Алгоритм:
- Чтение файла: SeqIO.parse(filename, "genbank").
- Расчет GC-состава:
 ```python
 gc_content = (seq.count("G") + seq.count("C")) / len(seq)
 ```
- Сортировка: sorted(sequences, key=lambda x: x[2]).

### Задание 3
 Библиотеки:
- `Bio.Seq` для трансляции.
 Алгоритм:
- Извлечение CDS из записей GenBank.
- Трансляция: seq.translate(table="стандартный_код").

## Ошибки и исправления
### Задание 1
1. Ошибка: Несовместимость форматов файлов от разных видов.
- Исправление: Проверка и конвертация в единый формат GenBank.
2. Ошибка: Отсутствие CDS в некоторых записях.
- Исправление: Фильтрация записей с if "CDS" in record.features.

### Задание 2
1. Ошибка: Некорректный расчет GC для пустых последовательностей.
- Исправление: Добавление проверки
 ```python
if len(seq) > 0
 ```  
2. Ошибка: Неправильная сортировка из-за строкового сравнения GC.
- Исправление: Преобразование GC в float перед сортировкой.

### Задание 3
1. Ошибка: Трансляция некодирующих областей.
- Исправление: Извлечение только CDS-фрагментов.
2. Ошибка: Игнорирование рамки считывания.
- Исправление: Учет frame в

 ```python
 feature.qualifiers.get("transl_table")
 ``` 

## Выводы
- Успешно создан объединенный GenBank-файл с 10+ CDS.
- Реализован расчет и сортировка GC-составов с выводом в GUI.
- Получены белковые последовательности через трансляцию CDS.

# Трассировка памяти

1) Использует модуль tracemalloc для отслеживания выделения памяти.
Сохраняет снимки памяти (snapshots) с временными метками.
После завершения обработки выводит:
- График потребления памяти в зависимости от времени.
- Размер самого большого блока памяти.
[код](https://github.com/gulidovalera/laba/blob/Labi/Python/биопитон%20tracemalloc.py)

## Результат
![](https://github.com/gulidovalera/laba/blob/Labi/Python/2025-05-19_12-55-46.png)
